{
  "language": "Solidity",
  "sources": {
    "contracts/oracles/chainlink/EthUsdChainlinkOracleId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nimport \"../interfaces/ILiveFeedOracleId.sol\";\nimport \"../utils/OwnableWithEmergencyOracleId.sol\";\n\ncontract EthUsdChainlinkOracleId is ILiveFeedOracleId, OwnableWithEmergencyOracleId {\n    // Chainlink\n    AggregatorV3Interface public priceFeed;\n\n    constructor(\n        IOracleAggregator _oracleAggregator,\n        uint256 _emergencyPeriod,\n        AggregatorV3Interface _priceFeed\n    ) OwnableWithEmergencyOracleId(_oracleAggregator, _emergencyPeriod) {\n        priceFeed = _priceFeed;\n\n        /*\n        {\n            \"author\": \"Opium.Team\",\n            \"description\": \"ETH/USD Oracle ID\",\n            \"asset\": \"ETH/USD\",\n            \"type\": \"onchain\",\n            \"source\": \"chainlink\",\n            \"logic\": \"none\",\n            \"path\": \"latestAnswer()\"\n        }\n        */\n        emit LogMetadataSet(\"{\\\"author\\\":\\\"Opium.Team\\\",\\\"description\\\":\\\"ETH/USD Oracle ID\\\",\\\"asset\\\":\\\"ETH/USD\\\",\\\"type\\\":\\\"onchain\\\",\\\"source\\\":\\\"chainlink\\\",\\\"logic\\\":\\\"none\\\",\\\"path\\\":\\\"latestAnswer()\\\"}\");\n    }\n\n    /** CHAINLINK */\n    function getResult() public view override returns (uint256) {\n        ( , int256 price, , , ) = priceFeed.latestRoundData();\n\n        // Data are provided with 8 decimals, adjust to 18 decimals\n        uint256 result = uint256(price) * 1e10;\n\n        return result;\n    }\n  \n    /** RESOLVER */\n    function _callback(uint256 _timestamp) external override {\n        uint256 result = getResult();\n        __callback(_timestamp, result);\n    }\n\n    /** GOVERNANCE */\n    function setPriceFeed(AggregatorV3Interface _priceFeed) external onlyOwner {\n        priceFeed = _priceFeed;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/oracles/interfaces/ILiveFeedOracleId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/// @title Opium.Interface.ILiveFeedOracleId is an interface that every LiveFeed oracleId should implement\ninterface ILiveFeedOracleId {\n    /// @notice \n    /// @param timestamp - Timestamp at which data are needed\n    function _callback(uint256 timestamp) external;\n\n    /// @notice Returns current value of the oracle if possible, or last known value\n    function getResult() external returns (uint256 result);\n\n    // Event with oracleId metadata JSON string (for Opium derivative explorer)\n    event LogMetadataSet(string metadata);\n}\n"
    },
    "contracts/oracles/utils/OwnableWithEmergencyOracleId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"opium-protocol-v2/contracts/interfaces/IOracleAggregator.sol\";\n\n/**\n    Error codes:\n    - O1 = Only when no data and after timestamp allowed\n    - O2 = Only when no data and after emergency period allowed\n */\ncontract OwnableWithEmergencyOracleId is Ownable {\n    // Opium\n    IOracleAggregator public oracleAggregator;\n\n    // Governance\n    uint256 public emergencyPeriod;\n\n    constructor(IOracleAggregator _oracleAggregator, uint256 _emergencyPeriod) {\n        // Opium\n        oracleAggregator = _oracleAggregator;\n\n        // Governance\n        emergencyPeriod = _emergencyPeriod;\n    }\n\n    /** RESOLVER */\n    function __callback(uint256 _timestamp, uint256 _result) internal {\n        require(\n            !oracleAggregator.hasData(address(this), _timestamp) &&\n            _timestamp <= block.timestamp,\n            \"O1\"\n        );\n\n        oracleAggregator.__callback(_timestamp, _result);\n    }\n\n    /** GOVERNANCE */\n    /** \n        Emergency callback allows to push data manually in case `emergencyPeriod` elapsed and no data were provided\n    */\n    function emergencyCallback(uint256 _timestamp, uint256 _result) external onlyOwner {\n        require(\n            !oracleAggregator.hasData(address(this), _timestamp) &&\n            _timestamp + emergencyPeriod <= block.timestamp,\n            \"O2\"\n        );\n\n        oracleAggregator.__callback(_timestamp, _result);\n    }\n\n    function setEmergencyPeriod(uint256 _newEmergencyPeriod) external onlyOwner {\n        emergencyPeriod = _newEmergencyPeriod;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "opium-protocol-v2/contracts/interfaces/IOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\ninterface IOracleAggregator {\n    function __callback(uint256 timestamp, uint256 data) external;\n\n    function getData(address oracleId, uint256 timestamp) external view returns (uint256 dataResult);\n\n    function hasData(address oracleId, uint256 timestamp) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/synthetics/options/OptionPutSyntheticId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"opium-protocol-v2/contracts/interfaces/IDerivativeLogic.sol\";\n\nimport \"../utils/ThirdPartyExecutionSyntheticId.sol\";\n\n/**\n    Error codes:\n    - S1 = CAN_NOT_BE_ZERO_ADDRESS\n */\ncontract OptionPutSyntheticId is IDerivativeLogic, ThirdPartyExecutionSyntheticId, Ownable {\n    address private author;\n    uint256 private commission;\n    uint256 public collateralization;\n\n    uint256 public constant BASE = 1e18;\n\n    constructor(address _author, uint256 _commission, uint256 _collateralization) {\n        /*\n        {\n            \"author\": \"Opium.Team\",\n            \"type\": \"option\",\n            \"subtype\": \"put\",\n            \"description\": \"Option Put logic contract\"\n        }\n        */\n        emit LogMetadataSet(\"{\\\"author\\\":\\\"Opium.Team\\\",\\\"type\\\":\\\"option\\\",\\\"subtype\\\":\\\"put\\\",\\\"description\\\":\\\"Option Put logic contract\\\"}\");\n\n        author = _author;\n        commission = _commission;\n        collateralization = _collateralization;\n\n        // Transfer contract's ownership to author on deployment\n        transferOwnership(_author);\n    }\n\n    // margin - reference value for option nominal\n    // params[0] - strikePrice - denominated in E18\n    // params[1] - fixedPremium - (optional)\n    function validateInput(LibDerivative.Derivative calldata _derivative) external override pure returns (bool) {\n        return (\n        // Derivative\n        _derivative.margin > 0 &&\n        _derivative.params.length == 2 &&\n\n        _derivative.params[0] > 0 // Strike price > 0\n        );\n    }\n\n    function getSyntheticIdName() external override pure returns (string memory) {\n        return \"OPT-C\";\n    }\n\n    function getMargin(LibDerivative.Derivative calldata _derivative) external override view returns (uint256 buyerMargin, uint256 sellerMargin) {\n        uint256 fixedPremium = _derivative.params[1];\n        buyerMargin = fixedPremium;\n\n        uint256 nominal = _derivative.margin;\n        sellerMargin = nominal * collateralization / BASE;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result) external override view returns (uint256 buyerPayout, uint256 sellerPayout) {\n        uint256 strikePrice = _derivative.params[0];\n        uint256 fixedPremium = _derivative.params[1];\n        uint256 nominal = _derivative.margin;\n        uint256 sellerMargin = nominal * collateralization / BASE;\n\n        // If result price is less than strike price, buyer is being paid out\n        if (_result < strikePrice) {\n            // Buyer payout is calculated as nominal multiplied by underlying result price depreciation from strike price\n            buyerPayout = nominal * (strikePrice - _result) / strikePrice;\n\n            // If Buyer payout exceeds the initial seller margin, then it's being capped (limited) by it\n            if (buyerPayout > sellerMargin) {\n                buyerPayout = sellerMargin;\n            }\n\n            // Seller payout is calculated as a reminder from seller margin and buyer payout\n            sellerPayout = sellerMargin - buyerPayout;\n        } else {\n            // If result price is lower or equal to strike price, buyer is not being paid out\n            buyerPayout = 0;\n            \n            // Seller receives its margin back as a payout\n            sellerPayout = sellerMargin;\n        }\n\n        // Seller payout is always increased by fixed premium if specified\n        sellerPayout = sellerPayout + fixedPremium;\n    }\n\n    /** COMMISSION */\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() external override view returns (address) {\n        return author;\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint256 syntheticId author commission\n    function getAuthorCommission() external override view returns (uint256) {\n        return commission;\n    }\n\n    /** THIRDPARTY EXECUTION */\n    function thirdpartyExecutionAllowed(address _derivativeOwner) external override view returns (bool) {\n        return isThirdPartyExecutionAllowed[_derivativeOwner];\n    }\n\n    function allowThirdpartyExecution(bool _allow) external override {\n        _allowThirdpartyExecution(msg.sender, _allow);\n    }\n\n    /** GOVERNANCE */\n    function setAuthorAddress(address _author) external onlyOwner {\n        require(_author != address(0), \"S1\");\n        author = _author;\n    }\n\n    function setAuthorCommission(uint256 _commission) external onlyOwner {\n        commission = _commission;\n    }\n\n    function setCollateralization(uint256 _collateralization) external onlyOwner {\n        collateralization = _collateralization;\n    }\n}\n"
    },
    "opium-protocol-v2/contracts/interfaces/IDerivativeLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\nimport \"../libs/LibDerivative.sol\";\n\n/// @title Opium.Interface.IDerivativeLogic is an interface that every syntheticId should implement\ninterface IDerivativeLogic {\n    // Event with syntheticId metadata JSON string (for DIB.ONE derivative explorer)\n    event LogMetadataSet(string metadata);\n\n    /// @notice Validates ticker\n    /// @param _derivative Derivative Instance of derivative to validate\n    /// @return Returns boolean whether ticker is valid\n    function validateInput(LibDerivative.Derivative memory _derivative) external view returns (bool);\n\n    /// @return Returns the custom name of a derivative ticker which will be used as part of the name of its positions\n    function getSyntheticIdName() external view returns (string memory);\n\n    /// @notice Calculates margin required for derivative creation\n    /// @param _derivative Derivative Instance of derivative\n    /// @return buyerMargin uint256 Margin needed from buyer (LONG position)\n    /// @return sellerMargin uint256 Margin needed from seller (SHORT position)\n    function getMargin(LibDerivative.Derivative memory _derivative)\n        external\n        view\n        returns (uint256 buyerMargin, uint256 sellerMargin);\n\n    /// @notice Calculates payout for derivative execution\n    /// @param _derivative Derivative Instance of derivative\n    /// @param _result uint256 Data retrieved from oracleId on the maturity\n    /// @return buyerPayout uint256 Payout in ratio for buyer (LONG position holder)\n    /// @return sellerPayout uint256 Payout in ratio for seller (SHORT position holder)\n    function getExecutionPayout(LibDerivative.Derivative memory _derivative, uint256 _result)\n        external\n        view\n        returns (uint256 buyerPayout, uint256 sellerPayout);\n\n    /// @notice Returns syntheticId author address for Opium commissions\n    /// @return authorAddress address The address of syntheticId address\n    function getAuthorAddress() external view returns (address authorAddress);\n\n    /// @notice Returns syntheticId author commission in base of COMMISSION_BASE\n    /// @return commission uint256 Author commission\n    function getAuthorCommission() external view returns (uint256 commission);\n\n    /// @notice Returns whether thirdparty could execute on derivative's owner's behalf\n    /// @param _derivativeOwner address Derivative owner address\n    /// @return Returns boolean whether _derivativeOwner allowed third party execution\n    function thirdpartyExecutionAllowed(address _derivativeOwner) external view returns (bool);\n\n    /// @notice Sets whether thirds parties are allowed or not to execute derivative's on msg.sender's behalf\n    /// @param _allow bool Flag for execution allowance\n    function allowThirdpartyExecution(bool _allow) external;\n}\n"
    },
    "contracts/synthetics/utils/ThirdPartyExecutionSyntheticId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ncontract ThirdPartyExecutionSyntheticId {\n    // Mapping containing whether msg.sender allowed his positions to be executed by third party\n    mapping (address => bool) internal isThirdPartyExecutionAllowed;\n\n    function _allowThirdpartyExecution(address _user, bool _allow) internal {\n        isThirdPartyExecutionAllowed[_user] = _allow;\n    }\n}\n"
    },
    "opium-protocol-v2/contracts/libs/LibDerivative.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.5;\n\n/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\nlibrary LibDerivative {\n    enum PositionType {\n        SHORT,\n        LONG\n    }\n\n    // Opium derivative structure (ticker) definition\n    struct Derivative {\n        // Margin parameter for syntheticId\n        uint256 margin;\n        // Maturity of derivative\n        uint256 endTime;\n        // Additional parameters for syntheticId\n        uint256[] params;\n        // oracleId of derivative\n        address oracleId;\n        // Margin token address of derivative\n        address token;\n        // syntheticId of derivative\n        address syntheticId;\n    }\n\n    /// @notice Calculates hash of provided Derivative\n    /// @param _derivative Derivative Instance of derivative to hash\n    /// @return derivativeHash bytes32 Derivative hash\n    function getDerivativeHash(Derivative memory _derivative) internal pure returns (bytes32 derivativeHash) {\n        derivativeHash = keccak256(\n            abi.encodePacked(\n                _derivative.margin,\n                _derivative.endTime,\n                _derivative.params,\n                _derivative.oracleId,\n                _derivative.token,\n                _derivative.syntheticId\n            )\n        );\n    }\n}\n"
    },
    "contracts/synthetics/options/OptionCallSyntheticId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"opium-protocol-v2/contracts/interfaces/IDerivativeLogic.sol\";\n\nimport \"../utils/ThirdPartyExecutionSyntheticId.sol\";\n\n/**\n    Error codes:\n    - S1 = CAN_NOT_BE_ZERO_ADDRESS\n */\ncontract OptionCallSyntheticId is IDerivativeLogic, ThirdPartyExecutionSyntheticId, Ownable {\n    address private author;\n    uint256 private commission;\n    uint256 public collateralization;\n\n    uint256 public constant BASE = 1e18;\n\n    constructor(address _author, uint256 _commission, uint256 _collateralization) {\n        /*\n        {\n            \"author\": \"Opium.Team\",\n            \"type\": \"option\",\n            \"subtype\": \"call\",\n            \"description\": \"Option Call logic contract\"\n        }\n        */\n        emit LogMetadataSet(\"{\\\"author\\\":\\\"Opium.Team\\\",\\\"type\\\":\\\"option\\\",\\\"subtype\\\":\\\"call\\\",\\\"description\\\":\\\"Option Call logic contract\\\"}\");\n\n        author = _author;\n        commission = _commission;\n        collateralization = _collateralization;\n\n        // Transfer contract's ownership to author on deployment\n        transferOwnership(_author);\n    }\n\n    // margin - reference value for option nominal\n    // params[0] - strikePrice - denominated in E18\n    // params[1] - fixedPremium - (optional)\n    function validateInput(LibDerivative.Derivative calldata _derivative) external override pure returns (bool) {\n        return (\n        // Derivative\n        _derivative.margin > 0 &&\n        _derivative.params.length == 2 &&\n\n        _derivative.params[0] > 0 // Strike price > 0\n        );\n    }\n\n    function getSyntheticIdName() external override pure returns (string memory) {\n        return \"OPT-C\";\n    }\n\n    function getMargin(LibDerivative.Derivative calldata _derivative) external override view returns (uint256 buyerMargin, uint256 sellerMargin) {\n        uint256 fixedPremium = _derivative.params[1];\n        buyerMargin = fixedPremium;\n\n        uint256 nominal = _derivative.margin;\n        sellerMargin = nominal * collateralization / BASE;\n    }\n\n    function getExecutionPayout(LibDerivative.Derivative calldata _derivative, uint256 _result) external override view returns (uint256 buyerPayout, uint256 sellerPayout) {\n        uint256 strikePrice = _derivative.params[0];\n        uint256 fixedPremium = _derivative.params[1];\n        uint256 nominal = _derivative.margin;\n        uint256 sellerMargin = nominal * collateralization / BASE;\n\n        // If result price is greater than strike price, buyer is being paid out\n        if (_result > strikePrice) {\n            // Buyer payout is calculated as nominal multiplied by underlying result price appreciation from strike price\n            buyerPayout = nominal * (_result - strikePrice) / _result;\n\n            // If Buyer payout exceeds the initial seller margin, then it's being capped (limited) by it\n            if (buyerPayout > sellerMargin) {\n                buyerPayout = sellerMargin;\n            }\n\n            // Seller payout is calculated as a reminder from seller margin and buyer payout\n            sellerPayout = sellerMargin - buyerPayout;\n        } else {\n            // If result price is lower or equal to strike price, buyer is not being paid out\n            buyerPayout = 0;\n            \n            // Seller receives its margin back as a payout\n            sellerPayout = sellerMargin;\n        }\n\n        // Seller payout is always increased by fixed premium if specified\n        sellerPayout = sellerPayout + fixedPremium;\n    }\n\n    /** COMMISSION */\n    /// @notice Getter for syntheticId author address\n    /// @return address syntheticId author address\n    function getAuthorAddress() external override view returns (address) {\n        return author;\n    }\n\n    /// @notice Getter for syntheticId author commission\n    /// @return uint256 syntheticId author commission\n    function getAuthorCommission() external override view returns (uint256) {\n        return commission;\n    }\n\n    /** THIRDPARTY EXECUTION */\n    function thirdpartyExecutionAllowed(address _derivativeOwner) external override view returns (bool) {\n        return isThirdPartyExecutionAllowed[_derivativeOwner];\n    }\n\n    function allowThirdpartyExecution(bool _allow) external override {\n        _allowThirdpartyExecution(msg.sender, _allow);\n    }\n\n    /** GOVERNANCE */\n    function setAuthorAddress(address _author) external onlyOwner {\n        require(_author != address(0), \"S1\");\n        author = _author;\n    }\n\n    function setAuthorCommission(uint256 _commission) external onlyOwner {\n        commission = _commission;\n    }\n\n    function setCollateralization(uint256 _collateralization) external onlyOwner {\n        collateralization = _collateralization;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}